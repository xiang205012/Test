

1. 单一职责原则：
        定义：不要存在多于一个导致类变更的原因，即一个类只负责一项职责

        问题由来：类T负责两个不同的职责：职责P1，职责P2。当由于职责P1需求发生改变而需要修改类T时，
                有可能会导致原本运行正常的职责P2功能发生故障。

        解决方案：遵循单一职责原则。分别建立两个类T1、T2，使T1完成职责P1功能，T2完成职责P2功能。
                这样，当修改类T1时，不会使职责P2发生故障风险；同理，当修改T2时，也不会使职责P1发生故障风险。


2. 里氏替换原则:
        定义1：如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，
              使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，
              那么类型 T2 是类型 T1 的子类型。

        定义2：所有引用基类的地方必须能透明地使用其子类的对象。

        问题由来：有一功能P1，由类A完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。
                 新功能P由类A的子类B来完成，则子类B在完成新功能P2的同时，有可能会导致原有功能P1发生故障。

        解决方案：当使用继承时，遵循里氏替换原则。类B继承类A时，除添加新的方法完成新增功能P2外，
                 尽量不要重写父类A的方法，也尽量不要重载父类A的方法。

           继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），
           实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，
           但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。

           继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。
           比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，
           如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，
           所有涉及到子类的功能都有可能会产生故障。

        举例说明继承的风险，我们需要完成一个两数相减的功能，由类A来负责。
            class A{
                public int func1(int a, int b){
                    return a-b;
                }
            }

            public class Client{
                public static void main(String[] args){
                    A a = new A();
                    System.out.println("100-50="+a.func1(100, 50));
                    System.out.println("100-80="+a.func1(100, 80));
                }
            }
            运行结果：

            100-50=50
            100-80=20

            后来，我们需要增加一个新的功能：完成两数相加，然后再与100求和，由类B来负责。即类B需要完成两个功能：

                两数相减。
                两数相加，然后再加100。

                由于类A已经实现了第一个功能，所以类B继承类A后，只需要再完成第二个功能就可以了，代码如下：
                    class B extends A{
                        public int func1(int a, int b){
                            return a+b;
                        }

                        public int func2(int a, int b){
                            return func1(a,b)+100;
                        }
                    }

                    public class Client{
                        public static void main(String[] args){
                            B b = new B();
                            System.out.println("100-50="+b.func1(100, 50));
                            System.out.println("100-80="+b.func1(100, 80));
                            System.out.println("100+20+100="+b.func2(100, 20));
                        }
                    }
                    类B完成后，运行结果：

                    100-50=150
                    100-80=180
                    100+20+100=220

                    我们发现原本运行正常的相减功能发生了错误。原因就是类B在给方法起名时无意中重写了父类的方法，
                    造成所有运行相减功能的代码全部调用了类B重写后的方法，造成原本运行正常的功能出现了错误。
                    在本例中，引用基类A完成的功能，换成子类B之后，发生了异常。在实际编程中，
                    我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，
                    但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。
                    如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，
                    原有的继承关系去掉，采用依赖、聚合，组合等关系代替。

                    里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：

                        1.子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
                        2.子类中可以增加自己特有的方法。
                        3.当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。
                        4.当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。

                        看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。
                        所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？

                        后果就是：你写的代码出问题的几率将会大大增加。


3. 依赖倒置原则：
        定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

        问题由来：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，
                 类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；
                 假如修改类A，会给程序带来不必要的风险。

        解决方案：将类A修改为依赖接口I，类B和类C各自实现接口I，类A通过接口I间接与类B或者类C发生联系，
                 则会大大降低修改类A的几率。

                 依赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。
                    以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。
                    在Java中，抽象指的是接口或者抽象类，细节就是具体的实现类，
                    使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，
                    把展现细节的任务交给他们的实现类去完成。

                 依赖倒置原则的核心思想是面向接口编程，我们依旧用一个例子来说明面向接口编程比相对于面向实现编程好在什么地方。
                 场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。代码如下：
                     class Book{
                         public String getContent(){
                             return "很久很久以前有一个阿拉伯的故事……";
                         }
                     }

                     class Mother{
                         public void narrate(Book book){
                             System.out.println("妈妈开始讲故事");
                             System.out.println(book.getContent());
                         }
                     }

                     public class Client{
                         public static void main(String[] args){
                             Mother mother = new Mother();
                             mother.narrate(new Book());
                         }
                     }
                    运行结果：
                    妈妈开始讲故事
                    很久很久以前有一个阿拉伯的故事……

                    运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：
                        class Newspaper{
                            public String getContent(){
                                return "林书豪38+7领导尼克斯击败湖人……";
                            }
                        }
                        这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，
                        只是将书换成报纸，居然必须要修改Mother才能读。假如以后需求换成杂志呢？换成网页呢？
                        还要不断地修改Mother，这显然不是好的设计。原因就是Mother与Book之间的耦合性太高了，
                        必须降低他们之间的耦合度才行。

                        我们引入一个抽象的接口IReader。读物，只要是带字的都属于读物：
                        interface IReader{
                            public String getContent();
                        }
                        Mother类与接口IReader发生依赖关系，而Book和Newspaper都属于读物的范畴，
                        他们各自都去实现IReader接口，这样就符合依赖倒置原则了，代码修改为：
                            class Newspaper implements IReader {
                                public String getContent(){
                                    return "林书豪17+9助尼克斯击败老鹰……";
                                }
                            }
                            class Book implements IReader{
                                public String getContent(){
                                    return "很久很久以前有一个阿拉伯的故事……";
                                }
                            }

                            class Mother{
                                public void narrate(IReader reader){
                                    System.out.println("妈妈开始讲故事");
                                    System.out.println(reader.getContent());
                                }
                            }

                            public class Client{
                                public static void main(String[] args){
                                    Mother mother = new Mother();
                                    mother.narrate(new Book());
                                    mother.narrate(new Newspaper());
                                }
                            }
                            运行结果：

                            妈妈开始讲故事
                            很久很久以前有一个阿拉伯的故事……
                            妈妈开始讲故事
                            林书豪17+9助尼克斯击败老鹰……

                            这样修改后，无论以后怎样扩展Client类，都不需要再修改Mother类了。
                            这只是一个简单的例子，实际情况中，代表高层模块的Mother类将负责完成主要的业务逻辑，
                            一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，
                            提高系统的稳定性，降低修改程序造成的风险。

                            采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，
                            原本Mother类与Book类直接耦合时，Mother类必须等Book类编码完成后才可以进行编码，
                            因为Mother类依赖于Book类。修改后的程序则可以同时开工，互不影响，
                            因为Mother与Book类一点关系也没有。参与协作开发的人越多、项目越庞大，
                            采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。

                            传递依赖关系有三种方式，以上的例子中使用的方法是接口传递，
                            另外还有两种传递方式：构造方法传递和setter方法传递，相信用过spring框架的，
                            对依赖的传递方式一定不会陌生。

                            在实际编程中，我们一般需要做到如下3点：
                                1.低层模块尽量都要有抽象类或接口，或者两者都有。
                                2.变量的声明类型尽量是抽象类或接口。
                                3.使用继承时遵循里氏替换原则。

                            依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。
















